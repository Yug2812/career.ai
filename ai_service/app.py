from flask import Flask, request, jsonify
from flask_cors import CORS
import random
try:
    import aiml  # python-aiml
    AIML_AVAILABLE = True
except Exception:
    AIML_AVAILABLE = False
import os
from typing import List, Dict
try:
    import joblib
    from sklearn.pipeline import Pipeline
    from sklearn.preprocessing import OneHotEncoder
    from sklearn.compose import ColumnTransformer
    from sklearn.ensemble import RandomForestClassifier
    import numpy as np
    SKLEARN_AVAILABLE = True
except Exception:
    SKLEARN_AVAILABLE = False

app = Flask(__name__)
CORS(app)

API_PREFIX = '/api'

# Initialize AIML Kernel if available
aiml_kernel = None
if AIML_AVAILABLE:
    try:
        aiml_kernel = aiml.Kernel()
        # Ensure the path is correct relative to the script
        aiml_kernel.learn(os.path.join(os.path.dirname(__file__), "aiml/career.aiml"))
        # Set a default predicate for safe fallbacks
        aiml_kernel.setPredicate("name", "CareerGuide")
        print("AIML kernel loaded.")
    except Exception as e:
        print(f"AIML load failed: {e}")
        aiml_kernel = None

# ===============
# ML Components
# ===============
MODEL_PATH = os.path.join(os.path.dirname(__file__), 'model.pkl')
ml_model = None
ml_feature_columns = ["subject", "problem", "projects", "environment", "motivation"]

def load_model_if_exists():
    global ml_model
    if SKLEARN_AVAILABLE and os.path.exists(MODEL_PATH):
        try:
            ml_model = joblib.load(MODEL_PATH)
            print("ML model loaded.")
        except Exception as e:
            print(f"Failed to load ML model: {e}")
            ml_model = None

load_model_if_exists()


@app.route(f'{API_PREFIX}/quiz/submit', methods=['POST'])
def quiz_submit():
    data = request.get_json(force=True, silent=True) or {}
    user_id = data.get('userId')
    answers = data.get('answers', {})

    if not user_id:
        return jsonify({ 'success': False, 'message': 'Missing userId' }), 400

    # If ML model is trained, predict target career
    career = None
    if ml_model is not None and SKLEARN_AVAILABLE:
        try:
            # We must convert the input dictionary into the list of values the model expects
            features_list = [answers.get(c, "") for c in ml_feature_columns]
            
            # Predict expects a list of samples, so we wrap the single sample in a list
            career = ml_model.predict([features_list])[0]
        except Exception as e:
            print(f"ML prediction failed: {e}")
            career = None

    # Fallback simple rule-based
    if not career:
        career = 'Full Stack Developer'
        # Check against string values based on input names in index.html
        if answers.get('subject') == 'math':
            career = 'Data Scientist'
        elif answers.get('problem') == 'creative':
            career = 'UX/UI Designer'
        elif answers.get('motivation') == 'impact':
            career = 'AI Ethics Consultant'

    results = {
        'recommendations': [career, 'Cloud Engineer', 'Project Manager', 'Technical Writer'],
        'skillReadiness': random.randint(45, 90),
        'targetCareer': career,
        'rawAnswers': answers
    }
    return jsonify({ 'success': True, 'message': 'Recommendations generated by Flask AI service.', 'results': results })


@app.route(f'{API_PREFIX}/ml/train', methods=['POST'])
def ml_train():
    if not SKLEARN_AVAILABLE:
        return jsonify({ 'success': False, 'message': 'scikit-learn not available on server.' }), 400

    payload = request.get_json(force=True, silent=True) or {}
    dataset: List[Dict] = payload.get('dataset', [])
    if not dataset or not isinstance(dataset, list):
        return jsonify({ 'success': False, 'message': 'Provide dataset: [{ features..., label }]' }), 400

    X = []
    y = []
    for row in dataset:
        features = [str(row.get(col, '')) for col in ml_feature_columns]
        label = row.get('label')
        if label is None:
            continue
        X.append(features)
        y.append(str(label))

    if len(X) == 0:
        return jsonify({ 'success': False, 'message': 'No valid rows with labels provided.' }), 400

    # Build pipeline: OneHotEncoder for categorical features + RandomForest
    try:
        # Create a preprocessor that applies OneHotEncoder to all feature columns
        encoder = OneHotEncoder(handle_unknown='ignore')
        preprocessor = ColumnTransformer([
            ('cat', encoder, list(range(len(ml_feature_columns))))
        ])
        
        clf = RandomForestClassifier(n_estimators=200, random_state=42)
        pipeline = Pipeline([
            ('prep', preprocessor),
            ('clf', clf)
        ])
        pipeline.fit(X, y)
        joblib.dump(pipeline, MODEL_PATH)
        global ml_model
        ml_model = pipeline
        return jsonify({ 'success': True, 'message': 'Model trained and saved.' })
    except Exception as e:
        return jsonify({ 'success': False, 'message': f'Training failed: {e}' }), 500


@app.route(f'{API_PREFIX}/resume/analyze', methods=['POST'])
def resume_analyze():
    data = request.get_json(force=True, silent=True) or {}
    user_id = data.get('userId')
    file_name = data.get('fileName', 'resume.pdf')

    if not user_id:
        return jsonify({ 'success': False, 'message': 'Missing userId' }), 400

    score = random.randint(60, 95)
    feedback = [
        { 'item': 'Targeted Keywords Match', 'score': 'Excellent' if score > 80 else 'Good' },
        { 'item': 'Formatting & Readability', 'score': 'Excellent' },
        { 'item': 'Experience Depth', 'score': 'Needs work' },
        { 'item': 'Action Verb Usage', 'score': 'Good' },
    ]
    return jsonify({ 'success': True, 'message': f'Analysis complete for {file_name}.', 'score': score, 'feedback': feedback })


@app.route(f'{API_PREFIX}/chatbot/query', methods=['POST'])
def chatbot_query():
    data = request.get_json(force=True, silent=True) or {}
    user_id = data.get('userId')
    query = data.get('query', '')

    if not user_id:
        return jsonify({ 'success': False, 'message': 'Missing userId' }), 400

    # Quick intent matcher (keyword-based) for higher quality defaults
    normalized = query.lower().strip()
    response = None
    intents = [
        (['salary', 'pay', 'ctc', 'package'],
         'Salaries vary by region and seniority. For a strong estimate: check recent reports (Levels.fyi, Glassdoor), filter by your city, and calibrate +/- 10% for skills and company tier.'),
        (['roadmap', 'path', 'how to become', 'become'],
         'A reliable roadmap: 1) Fundamentals (CS/Math or domain basics) 2) Core tools 3) Two portfolio projects 4) Mock interviews 5) Targeted applications (5–10/wk).'),
        (['skills', 'learn', 'what skills'],
         'Prioritize: problem solving, one primary language (Python/JS), data handling (SQL), and a cloud platform. Add role‑specific skills next (e.g., ML ops for DS, React for FE).'),
        (['resume', 'cv'],
         'Keep it 1 page (junior). Use action verbs + quantified impact. Mirror job keywords. Place projects above education if they’re stronger.'),
        (['interview', 'prepare', 'behavioral'],
         'Prep: daily timed practice (LeetCode/role tasks), 5 STAR stories (Situation–Task–Action–Result), and 2 mock interviews. Debrief after each session.')
    ]
    for keys, text in intents:
        if any(k in normalized for k in keys):
            response = text
            break

    # Try AIML next if available and no intent matched
    if aiml_kernel is not None:
        try:
            if not response:
                # AIML works best with uppercased patterns
                response = aiml_kernel.respond(query.strip())
        except Exception as e:
            # CORRECTED: Ensure the f-string is correctly closed on the same line
            print(f"AIML respond failed: {e}")
            response = None

    # Fallback rule-based response
    if not response:
        lower = query.lower()
        if 'salary' in lower:
            response = 'Depending on your location and experience, salaries can vary widely. Consider reviewing market reports and salary surveys for current figures.'
        else:
            response = f'I see you asked about "{query}". Consider exploring foundational courses and building a small project to gain practical exposure.'

    return jsonify({ 'success': True, 'response': response })


if __name__ == '__main__':
    # Changed default port from 5000 to 5001 to avoid "Address already in use" issues.
    app.run(host='0.0.0.0', port=5001, debug=True)


